Perf/BM library

OBJ: microbenchmark library for C++ small binaries with significant data structures.
OBJ: targeted for benchmarking operations on thread safe data structures
OBJ: exploit the highest resolution clock on Intel and AMD chipsets

REQ: Intel and AMD x86
REQ: C++ v >= 11
REQ: header only. All a user needs to do is #include "bm.h"
REQ: reduce variance caused by hardware jitter

NONREQ: reduce variance caused by hardware/kernel interrupts.
 NOTE: cannot prevent kernel interrupts or hardware interrupts so please run a few times
 NOTE: cannot prevent OOO execution
NONREQ: exception safety.
NONREQ: Windows

ALT:  google/benchmark [https://github.com/google/benchmark]
DIFF: overkill for small binaries
ALT:  sheredom/ubench [https://github.com/sheredom/ubench.h]
DIFF: uses linux clocks which loses resolution on ns

Example:
static void BM_KMP(const BM::State& state) {
	std::string space;
	std::string query;
	for (auto _ : state) {
		KnuthMorrisPrattSearch(space, query);
	}
}
BM_Register(BM_KMP);
BM_Main();

Testing:
Tests are a series of binaries in tests/
Create a series of interesting binaries to benchmark.
Use godbolt to verify that the correct machine instructions are being generated
 especially for preventing harmful micro-optimisations.

NOTE: kernel might interrupt and bring thread back onto a diff core, causing a diff RDTSC,
	we need to ignore those and warn the user

DESIGN NOTES
central contiguous array of Benchmark structs
add to it with BM_Register
run benchmarks and store with BM_Main (will use flags to configure how it is run and where results are written to)

vector<Benchmark*> bms;
Run():
	for b : bms
		b.run()
struct Benchmark {
	Name  // default name or user modified name
	Function // to run
	RunningState {
		args
		iteration count
	}
	Result {
		table of data that can be printed to ostream (where ostream can point to terminal device or file)
		report name of benchmark_arg, cpu time, wall time, iterations
	}
}

TODO: Initialize(&argc, argv) to process flags and turn on/off switches
	IDEA: flags library? I might try to break this out into its own library
		FLAG_DECLARE("FLAG_NAME", type, default_value, "what is it and how to use it");
		RETURN_IF_ERROR(FLAG_SET("FLAG_NAME", value));
		StatusOr<int> f = ASSIGN_OR_RETURN(FLAG_GET("FLAG_NAME"));
	TODO: proc/sysfs check testing: --test_tmp_dir 
	TODO: proc/sysfs check. namespace BM::System.
		Test by setting a flag --test_fs_root=$TMP_DIR
		Table: name of check, where to find in sysfs/procfs, what data is there, what we expect, what diff means
		TODO: check that cpupower frequency scaling is off. warn if its on.
			$ # Intel
			$ echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo
			$ # AMD
			$ echo 0 > /sys/devices/system/cpu/cpufreq/boost
	TODO: check that other processes aren't running. warn if others are running.
TODO: ShutDown() to write results
	TODO: Flag to specify terminal output, CSV  --output=csv --output_file=bm.csv
TODO: Run() to execute and record results
	TODO: pin benchmark to a CPU to reduce variance. Make this a parameter to BM::State instead of a flag?
	TODO: warmup flag: if set high, it will warmup the code path before measuring --benchmark_warmup=true
	TODO: random interleaving can reduce variation --benchmark_enable_random_interleaving=true
	TODO: specify non-zero repetition count --benchmark_repetitions=9
	TODO: decrease the per-repetition time --benchmark_min_time=0.1
	TODO: BM::State and RunState to capture execution (w/ support for for looping as in example)
class State {
 public:
  class iterator {
   public:
    iterator(RunState *ptr) : ptr_(ptr) {}
    iterator operator++() {
	  // TODO: sample rdtsc here and add to appropriate section
      ++ptr_;
      return *this;
    }
    bool operator!=(const iterator &other) const { return ptr_ != other.ptr_; }
    const RunState &operator*() const { return *ptr_; }

   private:
    RunState *ptr_;
  };

 private:
  unsigned len;
  RunState *arr;

 public:
  iterator begin() const { return iterator(arr); }
  iterator end() const { return iterator(arr + len); }
};

IDEA: fallback to chrono if rdtsc isn't available? Warn user about this.
TODO: BM::DoNotOptimize(void *p);
Escape and Clobber work together to trick the compiler into thinking we might globally use some data, thus it avoids optimizing it out
Effect of clobber() is limited to memory that is potentially accessible from an imagineary global root pointer.
From a compilers point of view, some data is completely hidden from the initial scope. Clobber pretends to touch all the data the global scope can see.
To ensure all data can be seen, we use scape.
// Marks p as arbitrarily aliased (to prevent dead code elim or scalar replacement of aggregate passes)
static void escape(void *p) {
	asm volatile("" : : "g"(p) : "memory");
}

// Aliases all the memory in the scope
static void clobber() {
	asm volatile("" : : : "memory");
}

void benchmark() {
	vector<int> v;
	v.reserve(1);
	v.push_back(10);
}

Benchmark would normally get mostly optimized out.
v.reserve(1) is not visible to clobber until we escape

void benchmark() {
	vector<int> v;
	v.reserve(1);
	escape(v.data());
	v.push_back(10);
	clobber();
}

IDEA: prevent reordering of instructions with fencing
e.g. Say we have uint8_t array;
prevent clflush from being reordered by the CPU or the compiler in this direction w/
_mm_mfence();
flush the line containing the element w/
_mm_clflush(&array[0]);

mfence and lfence must be in this order + compiler barrier for rdtsc
_mm_mfence();
_mm_lfence();
time1 = __rdtsc();

serialize __rdtsc with respect to trailing instructions + compiler barrier for rdtsc and the load
_mm_lfence();
int temp = array[0];  // this is a cache miss

measuring the write miss latency to array is not meaningful because it's an implementation detail and the next write may also miss
no need for mfence because there are no stores in between
mfence and lfence must be in this order + compiler barrier for rdtsc and the load
_mm_lfence();
time2 = __rdtsc();

serialize __rdtsc with respect to trailing instructions
_mm_lfence();
msl = time2 - time1;

