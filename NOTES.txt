Perf/BM library

OBJ: microbenchmark library for C++ small binaries with significant data structures.
OBJ: targeted for benchmarking operations on thread safe data structures
OBJ: exploit the highest resolution clock on Intel and AMD chipsets

REQ: Intel and AMD x86
REQ: C++ v >= 11
REQ: header only. All a user needs to do is #include "bm.h"
REQ: reduce variance caused by hardware jitter

NONREQ: reduce variance caused by hardware/kernel interrupts.
 NOTE: cannot prevent kernel interrupts or hardware interrupts so please run a few times
 NOTE: cannot prevent OOO execution
NONREQ: exception safety.
NONREQ: Windows

ALT:  google/benchmark [https://github.com/google/benchmark]
DIFF: overkill for small binaries
ALT:  sheredom/ubench [https://github.com/sheredom/ubench.h]
DIFF: uses linux clocks which loses resolution on ns

Example:
static void BM_KMP(const BM::State& state) {
	std::string space;
	std::string query;
	for (auto _ : state) {
		KnuthMorrisPrattSearch(space, query);
	}
}
BM_Register(BM_KMP);
BM_Main();

Testing:
Tests are a series of binaries in tests/
Create a series of interesting binaries to benchmark.
Use godbolt to verify that the correct machine instructions are being generated
 especially for preventing harmful micro-optimisations.

NOTE: kernel might interrupt and bring thread back onto a diff core, causing a diff RDTSC,
	we need to ignore those and warn the user

DESIGN NOTES
central contiguous array of Benchmark structs
add to it with BM_Register
run benchmarks and store with BM_Main (will use flags to configure how it is run and where results are written to)

vector<Benchmark*> bms;
Run():
	for b : bms
		b.run()
struct Benchmark {
	Name  // default name or user modified name
	Function // to run
	RunningState {
		args
		iteration count
	}
	Result {
		table of data that can be printed to ostream (where ostream can point to terminal device or file)
		report name of benchmark_arg, cpu time, wall time, iterations
	}
}

TODO: --warmup={True|False}. Default is true. BM will spend some time warming
up the codepath.
TODO: --enable_random_interleaving={True|False}. Default is true. To prevent
a CPU cache line from getting used to a particular codepath, BM will move the
BM onto different chips.
TODO: --min_repetitions={positive integer}. Default is 10. BM will repeat
benchmark at least min_repetitions times to get statistically significant
results.
TODO: --min_time={positive float}. Default is 1. BM will spend at least
min_time seconds on the benchmark.

TODO: ShutDown() to write results
	TODO: Flag to specify terminal output, CSV  --output=csv --output_file=bm.csv
TODO: Run() to execute and record results
	TODO: pin benchmark to a CPU to reduce variance. Make this a parameter to BM::State instead of a flag?
	TODO: warmup flag: if set high, it will warmup the code path before measuring --benchmark_warmup=true
	TODO: random interleaving can reduce variation --benchmark_enable_random_interleaving=true
	TODO: specify non-zero repetition count --benchmark_repetitions=9
	TODO: decrease the per-repetition time --benchmark_min_time=0.1
	NOTE: BM_RUN() should run until we have some statistically significant results. Some heuristics:
		running stddev or variance stops changing for some number of iterations?
		minimum_time < cpu_time
		1 < iters < 1e9
		5*minimum_time < real_time
	TODO: BM::State and RunState to capture execution (w/ support for for looping as in example)
		NOTE: record at the first iteration of state and when you exit the loop
		TODO: Add Args(A) and ArgRange(A-B)? To test how parameter size impacts benchmarks
		TODO: Add Threads(N)? To test how multithread impacts benchmarks
class State {
 public:
  class iterator {
   public:
    iterator(RunState *ptr) : ptr_(ptr) {
	  	// TODO: sample rdtsc here and add to appropriate section
		}
    iterator operator++() {
      ++ptr_;
      return *this;
    }
    bool operator!=(const iterator &other) const { return ptr_ != other.ptr_; }
    const RunState &operator*() const { return *ptr_; }
		~iterator() {
			// TODO: sample rdtsc here
		}

   private:
    RunState *ptr_;
  };

 private:
  unsigned len;
  RunState *arr;

 public:
  iterator begin() const { return iterator(arr); }
  iterator end() const { return iterator(arr + len); }
};

IDEA: fallback to chrono if rdtsc isn't available? Warn user about this.
TODO: BM::DoNotOptimize(void *p);
Escape and Clobber work together to trick the compiler into thinking we might globally use some data, thus it avoids optimizing it out
Effect of clobber() is limited to memory that is potentially accessible from an imagineary global root pointer.
From a compilers point of view, some data is completely hidden from the initial scope. Clobber pretends to touch all the data the global scope can see.
To ensure all data can be seen, we use scape.
// Marks p as arbitrarily aliased (to prevent dead code elim or scalar replacement of aggregate passes)
static void escape(void *p) {
	asm volatile("" : : "g"(p) : "memory");
}

// Aliases all the memory in the scope
static void clobber() {
	asm volatile("" : : : "memory");
}

void benchmark() {
	vector<int> v;
	v.reserve(1);
	v.push_back(10);
}

Benchmark would normally get mostly optimized out.
v.reserve(1) is not visible to clobber until we escape

void benchmark() {
	vector<int> v;
	v.reserve(1);
	escape(v.data());
	v.push_back(10);
	clobber();
}

IDEA: prevent reordering of instructions with fencing
e.g. Say we have uint8_t array;
prevent clflush from being reordered by the CPU or the compiler in this direction w/
_mm_mfence();
flush the line containing the element w/
_mm_clflush(&array[0]);

mfence and lfence must be in this order + compiler barrier for rdtsc
_mm_mfence();
_mm_lfence();
time1 = __rdtsc();

serialize __rdtsc with respect to trailing instructions + compiler barrier for rdtsc and the load
_mm_lfence();
int temp = array[0];  // this is a cache miss

measuring the write miss latency to array is not meaningful because it's an implementation detail and the next write may also miss
no need for mfence because there are no stores in between
mfence and lfence must be in this order + compiler barrier for rdtsc and the load
_mm_lfence();
time2 = __rdtsc();

serialize __rdtsc with respect to trailing instructions
_mm_lfence();
msl = time2 - time1;

FOR ANOTHER DAY
IDEA: flags library? I might try to break this out into its own library
	FLAG_DECLARE("FLAG_NAME", type, default_value, "what is it and how to use it");
	RETURN_IF_ERROR(FLAG_SET("FLAG_NAME", value));
	StatusOr<int> f = ASSIGN_OR_RETURN(FLAG_GET("FLAG_NAME"));
